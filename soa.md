## SOA落地浅谈

团队内部谈了很久系统分拆和面向服务，但是迟迟完全落不了地，是我们出发点错误？系统边界不合理？还是大家不理解？我想用自己的思考和解释来尝试简化一下SOA的概念，帮助大家理解。

#### 目录
1. 什么是SOA
2. SOA的设计原则
3. SOA和传统开发的异同
4. 如何SOA起来
5. 理想化SOA


#### 什么是SOA
根据wikipedia的[定义](http://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84)：面向服务的体系结构（Service-oriented architecture）是构造分布式计算的应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。它采用开放标准、与软件资源进行交互并采用表示的标准方式。

企业系统的架构师认为SOA能够帮助业务迅速和高效地响应变化的市场条件. 服务导向的架构在宏观（服务）上，而不是在微观上（对象）因此提高了重复使用性。同时，服务导向的架构可以简化与传统系统的互连和使用。

在某种意义上说，服务导向的架构可以被认为是一种演化，而不是革命。

那么，什么又是“服务”？按照OASIS的定义：Service是一种按照既定“接口”来访问一个或多个软件功能的机制（另外这种访问要符合“服务描述”中策略和限制）

#### SOA的设计原则
依旧部分引自wikipedia，我只想探讨以下几点：

1. 服务封装
2. 服务可重用性
3. 服务松耦合

类似于面向对象的高内聚、低耦合原则，面向服务的架构是在更高层次对这个原则的阐述。

再次引自wikipedia：在面向对象程式设计方法中，封装（Encapsulation）是指，一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。同时，它也是一种防止外界呼叫端，去存取物件内部实作细节的手段，这个手段是由编程语言本身来提供的。这两个概念有一些不同，但通常被混合使用。封装被视为是面向对象的四项原则之一。适当的封装，可以将物件使用接口的程式实作部份隐藏起来，不让使用者看到，同时确保使用者无法任意更改物件内部的重要资料。它可以让程式码更容易理解与维护，也加强了程式码的安全性。

面向服务的架构，是在应用系统级别上，对自身提供服务能力的表述，通过接口（API）的方式开放出来，供其它系统进行调用。其它系统只需关注API的要求和输出即可，不用关注其内部细节（平台，语言，对外部系统的依赖等等）。

经过仔细考虑过的API是能够cover住一些使用场景的，即提高自身的可重用性。比如：根据用户id来返回用户发表的最新5篇文章及其内容，可以设计为：

`getLastest5Articles(userId)`

其返回结构体如下：

Array(
	0 => array('title' => 'xxx', 'content' => 'xxx'),
	1 => array('title' => 'xxx', 'content' => 'xxx'),
)

但是随着需求发展，需要另外一个接口：根据用户id来返回用户发表的最新n篇文章及内容，改进如下：

`getLastestArticlesByNumber(userId, number)；`


业务总是变化的，而且返回内容会增加返回值，占用更多的带宽，此时，有系统又需要一个根据用户id，返回n篇最新文章，但是只要标题的：

`getLastestArticleTitles(userId, number)`

于是，三个接口看起来类似，但是又稍有不同的接口产生了。当然，可能会考虑还有自定义排序，返回不同的结构体，翻页等等。有点类似于我们在面向对象中写类的接口，是提供一个“全参数”方法，还是封装一个有明确含义的方法？按照面向对象的原则，我个人倾向于提供有具体业务含义的方法，而不要提供全参数的，因为全参数的使用上不但麻烦容易出错，一般还都会暴露实现。但是，对于面向服务的架构来说，又不能一味的遵从这个原则，即我们要在两者之前取一个平衡点，参数不要超过5个为好。比如对于上述接口来说，我们可以认为返回数，翻页作为基本属性，而是否携带内容、排序（正序和倒序）作为常用的附加属性（这点要具体视实际业务使用变化频率来定），把诸如隐私，作者自己看还是第三方看等作为业务属性，用不同的方法来区分（如getArticlesByAuthor），这样使用起来更清爽，不会让使用者困扰，又不会过多的增加新的接口。

请注意，在设计对外的API时，请一定站在使用者的角度去思考问题，即使用起来是否方便、是否没有歧义，而不能站在开发者的角度。不要用你自己发明的缩写（除非是业内通用的如HTML），尽可能完整的表达清楚接口的含义，不用怕长，因为自动补全技术已经很成熟了。如queryArticles1和queryArticles2这种，别人是不会知道其实际含义是：

* queryArticles1: getArticlesByAuthor(作者本人获取文章列表);
* queryArticles2: getArticlesByBrowser(第三方获取文章列表)。

使用实际业务含义来封装接口，不要怕麻烦，其内部实现依然是调用一系列公用方法，通过变参或者策略模式等将复杂问题简单化实施的，这些都是系统内部问题，与设计接口无关，使用者更不需要也不会关心这些问题。

另外，我想重点讨论以下耦合这个问题。

SOA的耦合，可以分为几个维度：

1. 实现上的耦合
2. 时间上的耦合
3. 版本上的耦合
4. 位置上的耦合

由于SOA天然的物理隔离，使得我们从宏观上要考虑系统边界（系统划分）和接口粒度的问题（避免分布式事务）。


##### 实现上的耦合
---
和面向对象开发类似，即使接口使用者（消费者），不需要依赖服务提供者某个特殊的实现，而一切都依赖于服务提供者的约定。这样，服务提供者的内部变更就不会影响到消费者。同样，消费者也可以根据自身需要自由选择和切换该约定的其它服务提供商。比如，新浪微博提供的API和twitter的一样，其在上线初期就可以就此吸引大批为twitter开发过客户端和程序的第三方平台加入，迅速扩张自己的应用范围，方便吸引更多的开发者加盟（因为对开发者来说学习和迁移成本很低）。

同时，我们提供的接口粒度，既不能过细（一个实现要调用多次，依赖返回值作为下一个接口的参数），又不能太粗（接口设计粒度，过多琐碎的业务规则接口）。这也需要我们在设计接口时，要充分理解业务模型，并且兼顾一定的前瞻性。高内聚，三个字，不好弄。

##### 时间上的耦合
---
这是SOA中非常核心的一个环节，典型来说就是消息队列（MessageQueue）。由于SOA会大量依赖外部系统的调用，且生产者（调用端）和消费者（被调用端）在吞吐量、可用性、复杂度等，在同一时间不尽相同，所以消息队列成了解决此问题的不二选择。由于有消息中心的存在，生产者可以在不关心答复的前提下，尽可能的提高其自身的吞吐量（立即返回消息给更高层），而留给消费者去自己消化。典型的应用如发送激活邮件、短信等。

同时，使用消息队列也可以极大缩短生产者的等待时间。一般情况下，我们是顺序调用接口或者执行db查询。但是，使用消息队列，可以看做是一种程序上的并发，即批量调用，逐个返回。举个例子，在A医院详情页，有如下调用场景：

1. 获取A医院的所有科室；
2. 获取A医院医生的最新回复的咨询；
3. 获取A医院医生的最新发表的文章；
4. 获取A医院好评最高的10位医生，并且获取他们的最新5篇文章和10篇最新点评；

可以想象代码调用如下：

```
hfs = getHospitalFaculties(hospitalId);
ps = getHospitalLastestProposals(hospitalId);
articles = getHopistalLastestArticles(hospitalId);
doctors = getHopistalTopDoctors(hospitalId, 10);
titles = getLastestArticleTitlesByBrowser(doctors, 5)；
comments = getLastestCommentsByBrowser(doctors, 10)；
```

因为是顺序调用，所以消耗时间是这些接口累加。

但是，如果使用mq来重新思考这个场景，我们可以改造如下：

```
hfs = getHospitalFaculties(hospitalId);
ps = getHospitalLastestProposals(hospitalId);
articles = getHopistalLastestArticles(hospitalId);
这三个接口比较独立，并发调用执行。
```

由于后两个方法依赖于doctors的返回，所以单独执行：

doctors = getHopistalTopDoctors(hospitalId, 10);

然后再打包执行：

```
titles = getLastestArticleTitlesByBrowser(doctors, 5)；
comments = getLastestCommentsByBrowser(doctors, 10)；
```
我们可以在提供准实时调用的mq上采用并发的方法，利用调用上的并行来减少等待的时间。当然，你也许会问调用失败了怎么办？顺序调用也同样存在失败的问题，想好你的处理机制即可。

当然，这样无论从设计到实施，都要比上边的顺序执行要复杂，此时，就需要我们在复杂度和执行效率上做平衡了。由于SOA的接口都是无状态的，即相互依赖是有限的，我还是倾向于在开发的时候认真思考归类，然后并发调用。

##### 版本上的耦合
---
理论上，消费者不需要依赖服务者的某个特殊版本来正常工作，及服务提供者在升级是，需要保证接口的向下兼容性问题。当然，这是理想情况，一般来说，对于内部SOA，可以保证在一定版本范围内实现兼容，然后发布升级通知，让所有消费者在指定时间内完成接口的迁移，之后老接口就可以废弃了。而公用SOA则因为消费者不可控而麻烦很多。这样也就需要我们在设计接口的时候，尽可能保证接口的单一性（影响范围小）。版本上的松耦合当然会对我们的编程提出更高的要求和更多的维护工作，这也会强迫我们在接口设计时多站在使用者的角度去考虑问题，从而尽可能减少自己的维护工作。


##### 位置上的耦合
---
这个概念也是伴随着SOA一并到来的，简单来说，就是服务在哪？

1. 我们可以使用域名调用的方式，来简化这个问题，服务提供者在其内部，基于域名可以做负载均衡或者其他高可用的实施，以保障对外服务的可用性。
2. 另外一种流行的方式，即通过服务注册中心来发现和使用服务。服务提供者可以在服务注册中心来维护自身的可用性，自动加入或者下线。消费者通过服务注册中心来感知，然后根据策略选出一个服务者进行调用。这样，消费者就不需要自身感知服务提供者的域名，ip等固化信息，从在位置上进一步解耦了。

我们当前使用既不是1也不是2，而是一种更原始的方式：消费者本身感知服务者ip，通过随机的策略选择出来一个进行调用。服务者的ip是写死在消费者代码中的。然后服务提供者再通过keepalived的机制，尽可能保障自身服务的可用性，来规避可能的问题。这种机制在服务相对比较稳定，且调用在可控范围内时是可行的，但是对服务提供者来说，自身的可扩展余地比较有限，如果消费者激增或者自身需要下线维护，则需要逐一修改消费者代码，并且重新发布。可以稍微调整一下来改变，及向消费者提供虚IP，然后利用lvs做物理隐藏，来规避这个问题。


